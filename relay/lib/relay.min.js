var Describe = function $Describe$($parent$$, $name$$, $op$$, $befores$$, $afters$$) {
  this.parent = $parent$$;
  this.name = $name$$;
  this.op = $op$$;
  this.children = [];
  this.id = describeCount++;
  this.befores = $befores$$ ? $befores$$ : [];
  this.afters = $afters$$ ? $afters$$ : []
};
Describe.prototype.toString = function $Describe$$toString$() {
  return this.name
};
Describe.prototype.perform = function $Describe$$perform$($callback$$) {
  var $self$$ = this;
  this.op();
  loop(0, this.children.length, function($i$$, $next$$) {
    enter($self$$.children[$i$$], $next$$)
  }, $callback$$)
};
var Expect = function $Expect$($parent$$, $value$$, $callStack$$) {
  this.parent = $parent$$;
  this.success = !1;
  this.value = $value$$;
  this.other = null;
  this.type = "";
  this.callStack = $callStack$$;
  $value$$ && (this.success = !0)
};
Expect.prototype.perform = function $Expect$$perform$($callback$$) {
  $callback$$()
};
Expect.prototype.toMatch = function $Expect$$toMatch$($matches_other$$) {
  this.other = $matches_other$$;
  this.success = ($matches_other$$ = this.value.match(RegExp($matches_other$$))) && 0 < $matches_other$$.length;
  this.type = "match"
};
Expect.prototype.toBe = function $Expect$$toBe$($other$$) {
  this.other = $other$$;
  this.success = this.value === $other$$;
  this.type = "be"
};
function isArray($a$$) {
  return"[object Array]" === Object.prototype.toString.apply($a$$)
}
function isObject($a$$) {
  return"object" == typeof $a$$
}
function isEqual($a$$, $b$$) {
  if(!$a$$ && $b$$ || $a$$ && !$b$$) {
    return!1
  }
  if($a$$ == $b$$) {
    return!0
  }
  if(isArray($a$$)) {
    if(isArray($b$$)) {
      if($a$$.length != $b$$.length) {
        return!1
      }
      for(var $bMembersCount_i$$ = 0;$bMembersCount_i$$ < $a$$.length;$bMembersCount_i$$++) {
        if($a$$[$bMembersCount_i$$] != $b$$[$bMembersCount_i$$]) {
          return!1
        }
      }
      return!0
    }
    return!1
  }
  if(isObject($a$$)) {
    if(!isObject($b$$)) {
      return!1
    }
    var $bMembersCount_i$$ = 0, $m$$;
    for($m$$ in $b$$) {
      $bMembersCount_i$$++
    }
    var $aMembersCount$$ = 0;
    for($m$$ in $a$$) {
      if($aMembersCount$$++, void 0 == $b$$[$m$$] || !isEqual($a$$[$m$$], $b$$[$m$$])) {
        return!1
      }
    }
    return $bMembersCount_i$$ != $aMembersCount$$ ? !1 : !0
  }
  return $a$$ == $b$$
}
Expect.prototype.toEqual = function $Expect$$toEqual$($other$$) {
  this.other = $other$$;
  this.success = isEqual(this.value, $other$$);
  this.type = "equal"
};
Expect.prototype.toNotEqual = function $Expect$$toNotEqual$($other$$) {
  this.other = $other$$;
  this.success = !isEqual(this.value, $other$$);
  this.type = "not equal"
};
Expect.prototype.toBeUndefined = function $Expect$$toBeUndefined$() {
  this.success = void 0 == this.val;
  this.type = "undefined"
};
Expect.prototype.toBeNull = function $Expect$$toBeNull$() {
  this.success = null == this.val;
  this.type = "null"
};
Expect.prototype.toString = function $Expect$$toString$() {
  var $str$$ = "expected " + this.value;
  "match" == this.type ? $str$$ += " to match " + this.other : "be" == this.type ? $str$$ += " to be " + this.other : "equal" == this.type ? $str$$ += " to equal " + this.other : "undefined" == this.type ? $str$$ += " to be undefined" : "null" == this.type && ($str$$ += " to be null");
  $str$$ += ": ";
  return $str$$ = this.success ? $str$$ + "success" : $str$$ + "failure"
};
var It = function $It$($parent$$, $name$$, $op$$, $befores$$, $afters$$) {
  this.parent = $parent$$;
  this.name = $name$$;
  this.op = $op$$;
  this.children = [];
  this.expects = [];
  this.id = itCount++;
  this.befores = $befores$$ ? $befores$$ : [];
  this.afters = $afters$$ ? $afters$$ : []
};
It.prototype.toString = function $It$$toString$() {
  return this.name
};
It.prototype.perform = function $It$$perform$($callback$$) {
  function $runMain$$() {
    $self$$.op();
    loop(0, $self$$.children.length, function($i$$, $next$$) {
      enter($self$$.children[$i$$], $next$$)
    }, $runExpects$$)
  }
  function $runExpects$$() {
    loop(0, $self$$.expects.length, function($i$$, $next$$) {
      enter($self$$.expects[$i$$], $next$$)
    }, $runAfters$$)
  }
  function $runAfters$$() {
    $self$$.afters ? loop(0, $self$$.afters.length, function($i$$, $next$$) {
      enter($self$$.afters[$i$$], $next$$)
    }, $callback$$) : $callback$$()
  }
  var $self$$ = this;
  $self$$.befores ? loop(0, $self$$.befores.length, function($i$$, $next$$) {
    enter($self$$.befores[$i$$], $next$$)
  }, $runMain$$) : $runMain$$()
};
var Listener = function $Listener$() {
};
Listener.prototype = {onEnter:function $Listener$$onEnter$() {
}, onExit:function $Listener$$onExit$() {
}};
function relayPeek() {
  return relayStack[relayStack.length - 1]
}
function describe($name$$, $op$$) {
  relayPeek().children.push(new Describe(relayPeek(), $name$$, $op$$, relayPeek().befores.slice(0), relayPeek().afters.slice(0)))
}
function beforeEach($op$$) {
  relayPeek().befores.push(new Run(relayPeek(), $op$$))
}
function afterEach($op$$) {
  relayPeek().afters.push(new Run(relayPeek(), $op$$))
}
function it($name$$, $op$$) {
  relayPeek().children.push(new It(relayPeek(), $name$$, $op$$, relayPeek().befores.slice(0), relayPeek().afters.slice(0)))
}
function runs($op$$, $timeout$$) {
  relayPeek().children.push(new Run(relayPeek(), $op$$, relayPeek().befores.slice(0), relayPeek().afters.slice(0), $timeout$$))
}
function expect($e$$) {
  $e$$ = new Expect(relayPeek(), $e$$, getCallStack(10));
  relayPeek().expects.push($e$$);
  return $e$$
}
function enter($part$$, $callback$$) {
  broadcast("onEnter", $part$$);
  relayStack.push($part$$);
  $part$$.perform(function() {
    exit($callback$$)
  })
}
function exit($callback$$) {
  var $part$$ = relayStack.pop();
  broadcast("onExit", $part$$);
  $callback$$()
}
function relay($timeout$$) {
  $timeout$$ && (defaultTimeout = $timeout$$);
  loop(0, root.children.length, function($i$$, $next$$) {
    enter(root.children[$i$$], $next$$)
  }, function() {
    console.log("Relay done.")
  })
}
function loop($iteration$$, $end$$, $operation$$, $finishCallback$$) {
  if($iteration$$ < $end$$) {
    $operation$$($iteration$$, function() {
      loop($iteration$$ + 1, $end$$, $operation$$, $finishCallback$$)
    })
  }else {
    return $finishCallback$$()
  }
}
function closestAncestor($element$$, $callback$$) {
  if(!$callback$$) {
    return $element$$.parent
  }
  for(var $ancestor$$ = $element$$.parent;!$callback$$($ancestor$$);) {
    $ancestor$$ = $ancestor$$.parent
  }
  return $ancestor$$
}
function getCallStack($size$$) {
  try {
    throw Error("");
  }catch($error$$) {
    for(var $frames$$ = [], $lines$$ = $error$$.stack.split("\n"), $i$$ = 0;$i$$ < $size$$ && $i$$ < $lines$$.length;$i$$++) {
      var $regexResult$$ = /[^\(]*\(([^\)]*)\)/ig.exec($lines$$[$i$$]);
      $regexResult$$ && 2 <= $regexResult$$.length && $frames$$.push(safeTagsReplace($regexResult$$[1]))
    }
    return $frames$$
  }
}
var tagsToReplace = {"&":"&amp;", "<":"&lt;", ">":"&gt;"};
function replaceTag($tag$$) {
  return tagsToReplace[$tag$$] || $tag$$
}
function safeTagsReplace($str$$) {
  return $str$$.replace(/[&<>]/g, replaceTag)
}
function addListener($listener$$) {
  listeners.push($listener$$)
}
function broadcast($message$$, $param$$) {
  for(var $i$$ = 0;$i$$ < listeners.length;$i$$++) {
    listeners[$i$$][$message$$]($param$$)
  }
}
var listeners = [], relayStack = [], root = new Describe;
relayStack.push(root);
var describeCount = 0, itCount = 0, defaultTimeout = null;
var Run = function $Run$($parent$$, $op$$, $befores$$, $afters$$, $timeout$$) {
  this.parent = $parent$$;
  this.op = $op$$;
  this.expects = [];
  this.ran = !1;
  $timeout$$ ? this.timeout = $timeout$$ : defaultTimeout && (this.timeout = defaultTimeout);
  $befores$$ && (this.befores = $befores$$);
  $afters$$ && (this.afters = $afters$$)
};
Run.prototype.perform = function $Run$$perform$($callback$$) {
  var $self$$ = this, $runTimeout$$;
  $self$$.timeout && ($runTimeout$$ = setTimeout(function() {
    $self$$.ran = !0;
    loop(0, $self$$.expects.length, function($i$$, $next$$) {
      enter($self$$.expects[$i$$], $next$$)
    }, function() {
      $self$$.reset();
      $callback$$()
    })
  }, $self$$.timeout));
  $self$$.op(function() {
    $self$$.ran ? console.error("Warning: run block completed after timed out.") : ($runTimeout$$ && clearTimeout($runTimeout$$), loop(0, $self$$.expects.length, function($i$$, $next$$) {
      enter($self$$.expects[$i$$], $next$$)
    }, function() {
      $self$$.reset();
      $callback$$()
    }))
  })
};
Run.prototype.reset = function $Run$$reset$() {
  this.ran = !1
};

